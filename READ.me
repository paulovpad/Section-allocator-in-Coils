# ğŸŒ€ Sistema de AlocaÃ§Ã£o de Linhas em Bobinas

1) Objetivo do algoritmo

O sistema aloca um conjunto de linhas/flexÃ­veis em uma ou mais bobinas, buscando aproveitar ao mÃ¡ximo a capacidade fÃ­sica de cada bobina e respeitando todos os limites operacionais:
Geometria: diÃ¢metro interno (DI), diÃ¢metro externo (DE) e largura Ãºtil da bobina;
FÃ­sica: limite de peso (kg/ton) e volume efetivo (com fator de empacotamento);
Linha: diÃ¢metro (mm), comprimento necessÃ¡rio (m), peso por metro (kg/m) e raio mÃ­nimo (m).
O resultado final Ã© um plano de bobinagem por camadas que indica, para cada camada, quais linhas entraram, quantas faixas (voltas) foram alocadas e quantos metros foram consumidos.

2) Modelo de Camada (o que Ã© uma â€œfaixaâ€)

A bobinagem acontece em camadas radiais (anÃ©is concÃªntricos). Dentro de uma camada, a linha ocupa a largura em â€œfaixasâ€ paralelas (tambÃ©m chamadas de â€œvoltasâ€ no relatÃ³rio).
Cada faixa corresponde a uma volta completa daquela linha em um raio mÃ©dio da camada.

DefiniÃ§Ãµes principais (para linha com diÃ¢metro d):

DiÃ¢metro real (m): d = diametro_mm / 1000

Passo de largura (m):
passo = d * (1 + 2*MARGEM_FRAC)
(a folga MARGEM_FRAC Ã© aplicada dos dois lados; ex.: 5% â†’ fator 1,10)

Raio mÃ©dio (m):
r_mid = r_base + d/2
(r_base Ã© o raio da superfÃ­cie interna da camada)

Comprimento por faixa (m):
C = 2Ï€ * r_mid

A capacidade teÃ³rica de faixas se a camada fosse sÃ³ dessa linha Ã©:
voltas_capacidade = floor(largura_bobina / passo).

3) RestriÃ§Ãµes verificadas para cada linha na camada

Uma linha sÃ³ pode contribuir faixas na camada se todas as condiÃ§Ãµes abaixo forem verdadeiras:

Geometria DE: ao usar essa linha na camada, a espessura da camada nÃ£o pode ultrapassar o DE:
2 * (r_base + d) â‰¤ DE.

Raio mÃ­nimo: o raio mÃ©dio da camada para essa linha precisa atender o raio_minimo_m:
r_mid â‰¥ raio_minimo_m.

Comprimento remanescente da linha:
Cada faixa consome C metros; entÃ£o o teto por remanescente Ã© floor(rem / C).

Peso e volume restantes da bobina:
O validador fornece max_comprimento_por_peso(bobina, linha) e max_comprimento_por_volume(bobina, linha).
Convertendo esses comprimentos para faixas:
floor(max_peso / C) e floor(max_volume / C).

Limite efetivo de faixas para a linha na camada:
qtd_max = min( por_remanescente, por_peso, por_volume ).

Obs.: a largura da bobina atua como capacidade global na etapa da mochila (ver abaixo).

4) SeleÃ§Ã£o Ã³tima por camada â€” Mochila inteira (Knapsack)

Para decidir quantas faixas de cada linha entram nesta camada, resolvemos um bounded knapsack:
Capacidade (W): a largura da bobina, discretizada em milÃ­metros (largura_m * 1000), para ganhar precisÃ£o em centÃ­metros/milÃ­metros.
Item: 1 faixa de uma linha especÃ­fica.
peso do item = passo * 1000 (mm de largura que consome);
valor do item = por padrÃ£o o mesmo (passo * 1000), ou seja, maximizar largura ocupada.
Disponibilidade por linha: atÃ© qtd_max cÃ³pias do item (faixas) daquela linha, limitado por remanescente, peso e volume.

DP 1D clÃ¡ssica:
dp[w] = melhor valor (largura ocupada) com capacidade w mm;
keep[w] guarda o caminho (qual item/cÃ³pia foi usado).
Percorremos os itens e, no fim, reconstruÃ­mos a soluÃ§Ã£o Ã³tima com keep, obtendo quantas faixas de cada linha entram na camada para ocupar a maior largura possÃ­vel.
Desempate opcional (sem mexer nas restriÃ§Ãµes):
Podemos somar um pequeno termo ao valor do item para priorizar mais comprimento alocado ou reduzir a sobra das linhas em empates de largura, mantendo o objetivo principal (largura) sempre dominante.

5) ConstruÃ§Ã£o da camada e avanÃ§o radial

Com a combinaÃ§Ã£o Ã³tima em mÃ£os:

Para cada linha selecionada:

voltas_usadas = nÃºmero de faixas escolhidas na DP;
comprimento_alocado = voltas_usadas * C;
Registramos na Camada (camada.adicionar_linha(...)) os campos que alimentam o relatÃ³rio: voltas_usadas, voltas_capacidade, passo, pos_y (r_mid), lado, comprimento_alocado.
Espessura da camada: Ã© o maior diÃ¢metro (m) entre as linhas usadas nessa camada.
Atualizamos o raio base: r_base += max_diÃ¢metro_usado.
Repetimos o processo de nova camada enquanto:
houver linhas com remanescente, e
2 * r_base â‰¤ DE (nÃ£o estouramos o diÃ¢metro externo).

6) SaÃ­da e relatÃ³rio

O relatÃ³rio por bobina apresenta:

Peso usado vs. permitido, e ocupaÃ§Ã£o volumÃ©trica (com fator de empacotamento);
Para cada camada:
DiÃ¢m. de base (2 Ã— r_base do inÃ­cio da camada),
Largura usada vs largura total,
Para cada linha: diÃ¢metro, comprimento alocado, voltas usadas/capacidade, passo, lado,
% de largura nÃ£o utilizada (sobra);
Linhas nÃ£o totalmente alocadas (remanescente > 0);
Resumo final (quantidade de bobinas, alocaÃ§Ãµes, etc.).

7) ParÃ¢metros e ajustes finos

MARGEM_FRAC (padrÃ£o 0,05): folga lateral entre faixas.
Aumentar â†’ menos faixas cabem por camada; Diminuir â†’ mais faixas (menos folga).
Desempate da mochila (opcional):
PadrÃ£o: valor = largura;
Largura + Comprimento: valor = largura_mm * 1e6 + comprimento_mm (prioriza mais metros sem perder o Ã³timo de largura);
Largura + Balanceamento: valor = largura_mm * 1e6 + f(sobra) para reduzir remanescentes â€œgrandesâ€ primeiro.
Esses ajustes nÃ£o violam a fÃ­sica (peso/volume/DE/raio continuam sendo checados para cada faixa), apenas mudam a preferÃªncia em empates de ocupaÃ§Ã£o.

8) Por que o algoritmo Ã© eficiente e condizente com a realidade

Maximiza a ocupaÃ§Ã£o da largura em cada camada (menos â€œburacosâ€);
Mistura linhas apenas quando isso melhora a ocupaÃ§Ã£o ou permite alocar mais metros sem violar limites;
Respeita peso e volume por faixa (com base em comprimento real pela circunferÃªncia);
Respeita DE e raio mÃ­nimo antes de cada alocaÃ§Ã£o;
Espessura conservadora da camada (maior diÃ¢metro usado) mantÃ©m a coerÃªncia geomÃ©trica;
EstÃ¡vel: pequenas variaÃ§Ãµes no input nÃ£o geram soluÃ§Ãµes â€œesdrÃºxulasâ€.